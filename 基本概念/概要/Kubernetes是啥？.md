# Kubernetes是啥？
本节将带你走进Kubernetes的世界，那美丽的世界，动人，充满诱惑，丝丝润滑，不融在手，只融在口，思而不学则die，盐多必失。
- [往事如烟](#往事如烟)
- [为啥要用k8s](#为啥要用k8s)
- [别瞎用](#别瞎用)
- [接下来……](#接下来)

Kubernetes，它是一个用来管理容器化应用和服务的开源平台，可移植，可扩展，帮我们实现声明式配置和自动化管理。Kubernetes的整个生态圈发展势头非常好。各种各样的服务、支持、工具，到处都是，满地都是。

Kubernetes这个词儿来源于希腊语，意即“舵手”。谷歌在2014年把k8s开源了。k8s中蕴含了谷歌超过15年的运行经验，并且从社区中获得了大量超级无敌优秀的思想。

## 往事如烟
让我们回首往事，看看k8s为什么现在这么牛逼。

![container_evolution](img/container_evolution.svg)

**上古时代**：企业把应用跑在物理服务器上。这种情况下无法界定资源，也就存在资源分配的问题。比如一堆程序跑在同一个物理机上，一旦某个程序占用了大量的资源，那其他程序就有可能要饿死了。一个解决方法是把每个程序安装在单独的物理机上。但是这样闹的话，就会存在资源利用率下降的问题，而且你让企业维护那么多物理机，搞笑呢。

**虚拟化时代**：嗯，对于上面的问题，虚拟化出现了。有了虚拟化，你就可以在一个物理机上运行多个虚拟机（VM）了。虚拟化可以在每个虚拟机之间进行资源隔离，这样，每个程序也就无法轻易访问到另一个虚拟机里的程序，提高了安全性。

虚拟化提高了物理机的资源利用率，可以更快的创建、更新应用程序，增加了可扩展性，降低了硬件成本，等等，还有好多优点。有了虚拟化，你的那堆物理机，就变成了一个可以任意调配的虚拟机集群。

每个虚拟机看上去就像是一个完整的物理机一样，有着自己的操作系统，运行在虚拟化硬件之上。

**容器时代**：看见没有，大明星来了。容器和虚拟机有点类似，但是它有着更加宽松的隔离机制，让多个应用程序能够共享操作系统。因此，容器是轻量级的。和虚拟机类似，一个容器有它自己的文件系统、CPU、内存、进程空间，等等。因为容器和底层设施解耦，因此它可以实现各种云环境、操作系统之间的可移植性。

容器之所以火起来，还有以下几个原因：

- 应用程序快速创建、部署：跟虚拟机的镜像相比，创建一个容器镜像更快更方便。
- 持续的开发、集成和部署：因为镜像的不可变的，可以提供快速方便的回滚，从而支持频繁、可靠的容器构建和部署。
- DevOps：可以在构建或者发布程序的时候就创建好容器的镜像，而不是部署的时候，这样也就把应用跟底层基础设施解耦了。
- 不光能提供OS层面的信息和指标，还能提供应用程序的健康信息和其他信息。
- 让开发、测试和生产环境保持一致：运行在笔记本上和运行在云上是一样的。
- 云环境和操作系统版本的可移植性：可以运行在Ubuntu、RHEL、CoreOS，或者是本地部署，或者是各种公有云环境，各种各种。
- 以应用为中心：把以前那种用虚拟资源跑OS的视角，提升到在OS上用逻辑资源跑应用的视角。
- 松耦合，分布式，弹性，自由的微服务：应用被打散成更小、更独立的分片，可以动态部署和管理——不再是用一个大机器跑一个沉重的应用。
- 资源隔离：你控制了资源，也就控制了应用程序的性能。
- 资源利用率：高效，嗯，高效。

## 为啥要用k8s
要想对你的程序进行打包和运行，选择容器真的挺不错的。在生产环境中，你来管理各种容器，确保他们不会让你的服务挂掉。比如，一个容器挂了，那就要启动另一个容器，野火烧不尽，春风吹又生。那么，如果有一个系统能帮你做这些事儿，岂不妙哉？

啊哈！k8s来啦！k8s可以将分布式系统运行在一个弹性的框架中。它来负责程序的扩展、故障转移，提供各种部署模式等等。比如，k8s可以很轻松的实现系统的灰度发布。

Kubernetes可以干这些事儿：

- **服务发现与负载均衡**

k8s可以通过DNS名称或IP地址把一个容器暴露出来。某个容器流量大了，k8s就会将流量分散，负载分散，使得整体保持稳定。
- **存储编排**

k8s可以根据设定自动挂载存储系统，本地存储、云存储，等等。
- **自动发布和回滚**

你可以用k8s来描述你的程序希望达到的目标状态，然后k8s会以一种可控的速率将程序的状态调整到你所希望的样子。比如，你可以让k8s为你自动创建新的容器、删除旧的，并且将回收的资源都分配给新的容器。
- **自动装箱**（说实话这个标题我没理解，不知道怎么跟下面的内容对应起来）

你搭了一堆节点，用k8s来运行容器化的程序。你告诉k8s每个容器需要多少CPU、多少内存。k8s会按需调配每个节点上的容器，让资源利用率最大化。
- **自愈**（金刚狼特性）

k8s会重启挂掉的容器，你可以自定义健康检查机制，k8s会杀掉并替换那些无法响应健康检查的容器，只有当容器一切准备妥当之后才会暴露给客户端。
- **安全信息与配置管理**

k8s可以管理密码、OAuth token、SSH密钥等敏感信息。部署、更新这些配置信息的时候，不需要重新构建容器镜像，敏感信息可以得到有效的保护。
## 别瞎用
别把k8s当PaaS。k8s考虑的是容器层面的东西，而不是硬件层面，它能提供一些和PaaS类似的功能，比如部署、扩展、负载均衡、日志和监控。但是这些东西并不是一个不可分割的整体，都是可选的、可配置的。对于构建一个开发平台，k8s提供了基本的组件，同时又给予用户充分的自由，让用户自己做出选择，更加的灵活。
因此我们要知道：

- k8s几乎不挑食。k8s旨在支撑各种各样的工作负载，无状态的、有状态的、数据处理的，等等。如果应用可以运行在容器里，放在k8s里只会变得更牛逼。

- k8s不负责源码部署和应用构建的工作。持续集成、发布、部署（CI/CD），这些东西由企业自己决定。

- 不提供应用级别的服务，比如中间件（比如消息总线）、数据处理框架（比如Spark）、数据库（比如MySQL）、缓存、分布式存储（比如Ceph）。k8s本身不干这些，但是这些东西可以运行在k8s上，运行在k8s上的其他应用可以通过一些可移植机制来访问这些服务，比如[Open Service Broker](https://www.openservicebrokerapi.org/)。

- 没有特定的日志收集、监控、告警机制。它提供一些集成方法，提供收集和暴露指标的机制。

- 不提供，也不依赖任何复杂的机器配置、维护、管理或自愈系统。

- 此外，k8s可不仅仅是一个编排系统。实际上，它让你不再需要编排。从概念上讲，一个编排系统要执行一个预定义的工作流：先A再B再C。k8s由一系列独立的控制进程组合而成，它们持续的将系统的当前状态向目标状态推进。至于怎么样从A到C，这个应该是无关紧要的，也不需要集中化的控制。这样的系统使用起来更加简单，更强大、健壮、弹性并且可扩展。
## 接下来……
- 去瞅瞅[Kubernetes组成](Kubernetes组成.md)
- 这就[准备开始]()了吗？不再聊会儿了？