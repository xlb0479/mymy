# 管理容器资源

当你定义了一个[Pod](../业务组件/泡德（Pod）/Pod.md)，你还可以定义每个[容器](../概要/Kubernetes是啥？.md)需要用多少资源。最常见的就是CPU和内存了（RAM）；当然也有其他的。

当你给Pod中的容器设置了资源*请求（request）*，调度器会根据这个值来判断Pod可以被调度到哪个节点上。当你给容器设置了资源*上限（limit）*，kubelet会强制施加限制，保证容器使用的资源不会超过你设定的上限。同时，kubelet还会保证留下至少资源*请求*的数量，保证容器需要的最少资源。

## 请求（request）和限制（limit）

如果Pod所在的节点有足够的资源，那就能够（允许）让容器使用资源超过它的`request`。但是容器使用的资源不能超过`limit`。

比如你设置了容器的`memory`请求值为256MiB，它所在的Pod被调度到了一个拥有8GiB内存的节点上，并且该节点没有其他Pod，那这个容器就可以使用更多的RAM。

如果你为容器设置了`memory`的上限为`4GiB，kubelet（以及[容器运行时](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)）会强制执行这个限制。这个运行时会限制容器使用的资源不超过设定的上限。比如：进程中的容器想要使用超过上限的内存，系统内核会停掉尝试分配内存的进程，并给出一个内存不足（OOM）的错误信息。

限制措施可以实现成反应式的（当系统发现非法操作时进行干预）或者是强制型的（系统阻止容器超过上限）。不同的运行时对同一种限制也会有不同的实现方法。

## 资源类型

*CPU*和*内存*都是*资源类型*。每个资源类型都有一个基本单位。CPU代表着计算处理，使用[k8s CPU](#CPU的含义)单位。内存使用字节单位。如果你用的是v1.14或以上版本，还可以设置*大页内存（huge page）*资源。大页内存是Linux的特性，节点内核可以分配的内存块要远大于默认的页大小。

比如一个系统默认页大小是4KiB，你可以设置一个上限，`hugepages-2Mi: 80Mi`。如果容器尝试分配超过40个2MiB的大页（总计80MiB），分配就会失败。

>**注意**：不能过度使用`hugepages-*`资源。这种资源跟`memory`和`cpu`不一样哦。

CPU和内存统称为*计算资源（compute resource）*，或者直接叫*资源（resource）*。计算资源是可以根据数量度量进行请求、分配和使用的。它们跟[API资源](../概要/Kubernetes%20API.md)不同。API资源，比如Pod和[Service](../Service，负载均衡，网络/Service.md)都是对象，可以通过apiserver进行读取和修改。

## Pod和容器的资源请求与限制

一个Pod中的每个容器都可以设置一个或多个：

- `spec.containers[].resources.limits.cpu`
- `spec.containers[].resources.limits.memory`
- `spec.containers[].resources.limits.hugepages-<size>`
- `spec.containers[].resources.requests.cpu`
- `spec.containers[].resources.requests.memory`
- `spec.containers[].resources.requests.hugepages-<size>`

尽管请求和限制只能基于特定容器进行设定，获取Pod级别的资源请求和限制也是很方便的。对于某个资源类型，*Pod资源请求/限制*值就是其中每个容器的对该资源的请求/限制总和。

## k8s中的资源单位

### CPU的含义

CPU的请求和限制用*cpu*单位进行度量。在k8s中，一个CPU，就等于云服务商的**1个vCPU或1个内核**，对于裸金属的Intel处理器来说就是**1个超线程**。

可以按小数进行请求。如果容器设定的`spec.containers[].resources.requests.cpu`值为`0.5`，就保证可以请求1个CPU的一半。同时，`0.1`还等于`100m`，读作“100个millicpu”，有些人也读作“100个millicore”，都是一样的意思。如果请求值带了小数，比如`0.1`，会被CPU转换成`100m`，不允许比`1m`更小的精度。所以，更倾向于使用`100m`这种格式。

CPU总是按照绝对数量进行请求的，而不会是相对数量；0.1在单核、双核，甚至48核的机器上代表的数量都是一样的。

### 内存的含义

`memory`的请求和限制用字节进行度量。可以用普通的整数或者定点数来表示内存，并加上这些后缀之一：E、P、T、G、M、K。还可以使用对应的二次方形式：Ei、Pi、Ti、Gi、Mi、Ki。比如下面这些基本上都是差不多一样的值：

```text
128974848, 129e6, 129M, 123Mi
```

这里有个栗子。下面这个Pod有两个容器。每个容器都请求了0.25个CPU和64MiB（2<sup>26</sup>字节）的内存。每个容器资源上限都是0.5个CPU和128MiB内存。那我们就可以说，这个Pod请求了0.5个CPU和128MiB内存，上限为1个CPU和256MiB内存。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: app
    image: images.my-company.example/app:v4
    env: # 我去，这里空着？？？
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
  - name: log-aggregator
    image: images.my-company.example/log-aggregator:v6
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
```

## 带资源请求的Pod是如何调度的

当你创建了一个Pod，k8s的调度器就要为这个Pod选择一个合适的节点。对于每种资源，每个节点都有它的最大容量值：它可以为Pod提供的CPU和内存数量。调度器能够确保对于每种资源，容器的请求值总和要小于节点的容量值。需要注意的是，尽管节点上真实使用的内存或CPU资源可能非常低，但如果容量检查不通过，调度器依然不会对Pod进行调度。这就保证了在之后可能出现资源使用率上升的情况下不会出现资源不足的问题，比如每日的请求高峰期。

## 带资源限制的Pod是怎么运行的

当kubelet启动了Pod中的一个容器，它会将CPU和内存的限制传给容器运行时。

对于Docker：

- `spec.containers[].resources.requests.cpu`会被转换成它的核数，可能是小数，然后乘以1024。得到的这个值和2进行比较，取较大值，作为`docker run`命令的[`--cpu-shares`](https://docs.docker.com/engine/reference/run/#cpu-share-constraint)选项。
- `spec.containers[].resources.limits.cpu`会转换成millicore值，然后乘以100。结果值就代表每100毫秒，容器可以使用的CPU时间上限。在这个时间内，容器可用的CPU时间无法超过这个上限。

>**注意**：默认的周期配额就是100毫秒。CPU最小周期配额为1毫秒。

- `spec.containers[].resources.limits.memory`会转换成一个整数，作为`docker run`命令的[`--memory`](https://docs.docker.com/engine/reference/run/#/user-memory-constraints)选项的值。