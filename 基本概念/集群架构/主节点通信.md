# 主节点通信

本文来讲讲主节点（可以当成是apiserver吧）和k8s集群的通信链路。通过这部分的学习，用户可以强化k8s的网络环境配置，比如将集群安装在不授信的网络中（或者完全安装在云服务商的公网IP上）。

- [集群到Master](#集群到Master)
- [Master到集群](#Master到集群)

## 集群到Master

所有从集群指向Master的链路最终都会落到apiserver上（Master上的其他组件都不会暴露可远程访问的服务）。典型的部署方式是，apiserver监听HTTPS端口（443），接受远程连接，并且至少开启一种客户端[授权模式]()，特别是允许[匿名请求]()，或[服务账号令牌]()的情况。

节点这边应当使用公共根证书，这样才能用有效的客户端证书连接到apiserver上。比如在一套默认的GKE环境中，kubelet的客户端凭证就是证书的形式。关于如何自动获取kubelet的客户端证书，详见[kubelet TLS启动]()。

Pod可以用服务账户的形式安全的连接到apiserver上，当Pod实例化的时候，k8s会自动将公共根证书和一个令牌注入到Pod里。在所有命名空间中，`kubernetes`服务都配置了重定向到apiserver的HTTPS端点的虚拟IP（通过kube-proxy）。

主节点的组件也是通过安全端口跟apiserver通信。

有了这些配置，默认情况下由集群（节点和运行在节点上的Pod）指向主节点的连接就有了安全保障，可以运行在非授信或公共网络中了。

## Master到集群

这个方向上主要由两条线。一条是从apiserver指向每个节点的kubelet进程。另一条是通过apiserver的代理功能，从apiserver指向任意的节点、pod或服务。

### apiserver到kubelet

这条线的作用包括：

- 抓取pod的日志。
- 通过kubectl工具附加到正在运行的pod上。
- 为kubelet提供端口转发功能。

这些连接最终都发到kubelet的HTTPS接口上。默认情况下apiserver不会去验证kubelet的服务端证书，也就是说可能会受到中间人攻击，而且如果运行在公共网络或非授信网络上，也是**不安全**的。

如果想验证的话，可以通过`--kubelet-certificate-authority`选项为apiserver提供根证书。

如果这条路走不通，可以用[SSH隧道](#SSH隧道)，避免通过公共网络或非授信网络进行连接。

总的来说，需要开启[kubelet的认证和授权]()来保护kubelet的API。

### apiserver到节点、pod和服务

这条线上的连接都是明文HTTP请求，没有认证和加密。可以在请求时使用`https:`前缀，但是并不会验证服务端证书，也没有客户端凭证，所以也就不会加密，没有任何完整性保障。所以，将这条线暴露在公共或非授信网络时，**目前来说是不安全的**。

### SSH隧道

k8s支持将这条线通过SSH隧道技术保护起来。这种情况下，apiserver会建立跟每个节点的SSH隧道（连接到ssh的22端口），所有发向kubelet、节点、pod和服务的流量都从隧道上走。隧道保证里流量不会暴露到外部网络中。

这种方式目前已经废弃了，想用也行，但是你要明确的知道你是不是要这么干。取而代之的是Konnectivity服务。

### Konnectivity服务

**功能状态**：`Kubernetes v1.18`（beta）

作为SSH隧道的替代方案，Konnectivity服务为这条线提供TCP层面的代理。此宝宝包含两部分，服务端和代理端，分别运行在主节点和集群上。从代理端建立到服务端的连接。这条线上的所有流量都通过这些连接来传输。

见[如何安装Konnectivity服务]()。