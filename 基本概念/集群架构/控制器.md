# 控制器

学术点儿讲，*控制循环*就是通过无休止的循环来控制系统的状态。

比如一个室内恒温器。

你设置一个温度值，就是为恒温器提供一个*目标状态*。真正的室内温度是*当前状态*。恒温器通过一通骚操作，将当前状态向目标状态推进。

在k8s中，控制器就是监控集群状态的控制循环，负责做出调整或请求做出调整。每个控制器都是在将系统的当前状态向目标状态推进。

- [控制器模式](#控制器模式)
- [目标状态和当前状态](#目标状态和当前状态)
- [设计思路](#设计思路)
- [运行控制器的各种方式](#运行控制器的各种方式)
- [接下来……](#接下来)

## 控制器模式

一个控制器至少负责一类k8s资源。这些[对象](../概要/Kubernetes对象/理解Kubernetes对象%20.md#理解k8s对象)都有一个spec字段，描述其目标状态。控制器负责将资源的当前状态向目标状态推进。

这些控制器要么自己直接干，要么给apiserver发消息。下面分别介绍这里两种方式。

### 通过APIServer来控制资源

Job控制器是k8s的内置控制器，内置控制器是要通过API服务来管理状态的。

所谓Job，就是要运行一个或多个Pod，完成某个任务，然后结束。

（一旦调度完成，Pod对象就成了kubelet目标状态的一部分）。

Job控制器创建任务的时候会确保集群中有足够数量的Pod来完成任务。Job控制器本身并不运行任何Pod或容器，而是交给apiserver去做。control plane的其他组件也会做出响应（要调度新的Pod啦），最终把任务完美的跑起来。

创建Job后，Job就要实现它的目标状态。Job控制器将Job的当前状态向目标状态推进：创建Job所需的Pod，让Job得以完成它的工作。

控制器还需要更新资源对象。比如Job的任务完成之后，Job控制器要把Job对象标记为`Finished`。

（同样，室内温度达标后，恒温器也会关闭一些相应的功能）。

### 直接干

跟Job控制器不同，有些控制器需要调整集群外部的东西。

比如要通过一个控制循环来保证集群中有足够数量的节点，那么这种控制器就要获取一些集群外部的信息，为集群创建新的节点。

此时要先从apiserver中获取目标状态，然后直接跟外部系统打交道，开始向目标状态推进。

（真的有这种控制器呦，别以为我是在这儿瞎扯淡，见[集群自动扩展]()）。

## 目标状态和当前状态

k8s以一种云原生的视角开看待系统，持续处理各种状态变更。

集群在任何时间都可以能发生变化，同时还要运行各种工作，控制循环还要修复可能出现的问题。也就是说，集群永远不会达到一个稳定的状态（莫慌）。

只要各种控制器能够正常的运行，至于整体状态是否问题，就不那么重要了。

## 设计思路

k8s的原则之一，就是让每个控制器去管理集群状态的某一特定部分。一般来说，控制器使用某种资源作为目标状态，然后用另一种资源来推进当前状态。就拿上面说过的Job来说，Job的控制器要监管Job对象（发现新的任务）和Pod对象（运行Job然后看看啥时候任务完成）。此时，由其他部分来创建Job，Job控制器来创建Pod。

用多个功能简单互相关联的控制器，要比一组整体的控制循环要更加优秀。这样k8s就可以允许控制器出错。

>**注意**：
>同一种类型的对象，可以由多个控制器来创建和更新。k8s的每个控制器只操心跟自己相关的资源。
>
>比如既可以建Deployment也可以建Job；它们都会去创建Pod。Job控制器不会去删除Deployment建的Pod，Pod上有辅助信息（标签）可以让控制器将Pod们区分开来。

## 运行控制器的各种方式

kube-controller-manager中运行着一系列内置的控制器。这些控制器提供了重要的核心功能。

Deployment控制器和Job控制器就属于这些内置控制器。control plane是弹性的，某个内置控制器出错，另一部分就会过来接管工作。

有一些控制器运行在control plane之外，对k8s进行扩展。或者说，你自己可以写一个新的控制器（你真牛逼）。比如用一堆Pod来实现自己的控制器，或者，运行在k8s之外。总之，最适合的就是最好的。

## 接下来……

- 看看[k8s的control plane](../基本概念.md#kubernetes-control-plane)
- 了解一些基本的[k8s对象](../基本概念.md#Kubernetes对象)
- 学学[k8s的API]()
- 要不要写个自己的控制器呀，[看看如何扩展]()。