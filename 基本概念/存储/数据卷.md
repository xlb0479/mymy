# 数据卷

容器中的磁盘文件都是短暂的，这样就为一些特殊的应用运行在容器中带来了一些困扰。首先呢，当容器挂了，kubelet就要重启它，但是文件就都没了——容器以全新的状态启动。第二，当Pod中运行多个容器的时候，常常需要共享一些文件。`Volume`的出现解决了这两个问题。

建议你先去学习完[Pod](../业务组件/泡德（Pod）/Pod.md)再过来。

## 背景

Docker也有[数据卷](https://docs.docker.com/storage/)的概念，尽管相对来说更加简单，管理也比较少。在Docker里，一个数据卷基本上就是一个磁盘目录或者是在另一个容器里。其生命周期不受管理，而且直到最近依然只支持基于本地磁盘的数据卷。Docker现在提供了数据卷驱动，但是功能很有限（比如到Docker 1.7每个容器只能用一个数据卷驱动，而且还无法给数据卷传递参数）。

但在k8s中的数据卷就不一样了，哈呀，这就要开始吹牛逼了，它是有明确生命周期的——和围绕它的Pod保持一致。这就是说，这里的数据卷脱离了容器，而是关联到了Pod这一层面上，因此在容器重启的过程中数据依然能够保留下来。当然，如果Pod退出了，那数据卷也就跟着退出了。更重要的是，k8s还能支持好多好多种的数据卷，一个Pod可以同时使用任意数量的各种类型的数据卷。

数据卷的核心就是一个目录，可能还包含一些数据在里面，然后Pod中的容器可以访问到这些数据和目录。这个目录怎么来、中间介质是怎样的，以及其中包含的东西，都是由特定的数据卷类型来决定的。

要使用数据卷，Pod需要定义用到的数据卷（`.spec.volumes`字段），以及这些数据卷要挂载到容器的什么地方去（`.spec.containers[*].volumeMounts`字段）。

容器中的一个进程看到的文件系统是由Docker镜像和数据卷组合而成的。[Docker镜像](https://docs.docker.com/get-started/)位于文件系统的最底层，任何数据卷都是挂载到镜像的特定位置上的。Pod中的每个容器必须要单独声明数据卷的挂载位置。

## 数据卷类型

k8s支持好多种数据卷：

- [awsElasticBlockStore]()
- [azureDisk]()
- [azureFile]()
- [cephfs]()
- [cinder]()
- [configMap](#configmap)
- [csi]()
- [downwardAPI]()
- [emptyDir](#emptydir)
- [fc (fibre channel)]()
- [flexVolume]()
- [flocker]()
- [gcePersistentDisk]()
- [gitRepo (deprecated)]()
- [glusterfs]()
- [hostPath](#hostPath)
- [iscsi]()
- [local](#local)
- [nfs](#nfs)
- [persistentVolumeClaim](#persistentVolumeClaim)
- [projected](#projected)
- [portworxVolume]()
- [quobyte]()
- [rbd]()
- [scaleIO]()
- [secret](#secret)
- [storageos]()
- [vsphereVolume]()

我们欢迎大家贡献其他的类型。在这里，由于数据卷类型太多了，我只翻译一下常用的，或者说是我个人感兴趣的部分。

### configMap

[`configMap`](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/)提供了一种将配置信息注入到Pod中的方法。保存在`ConfigMap`对象中的数据可以通过`configMap`类型的数据卷来引用，被Pod中的容器化应用所使用。

当你需要引用一个`configMap`对象，在数据卷中指定名字即可。还可以自定义要使用的ConfigMap中的某个路径。比如要将名为`log-config`的ConfigMap挂载到一个叫`configmap-pod`的Pod中，YAML可以这样写：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: configmap-pod
spec:
  containers:
    - name: test
      image: busybox
      volumeMounts:
        - name: config-vol
          mountPath: /etc/config
  volumes:
    - name: config-vol
      configMap:
        name: log-config
        items:
          - key: log_level
            path: log_level
```

`log-config`被当成了一个数据卷，它的`log_level`记录中保存的内容被挂载到了容器中的“`/etc/config/log_level`”路径上。注意这个路径是基于数据卷的`mountPath`和`path`的名字`log_level`组成的。

>**警告**：使用[ConfigMap](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/)必须先创建它。

>**注意**：如果容器将ConfigMap作为[subPath](#使用subPath)数据卷进行挂载，是无法感知到ConfigMap的更新的。

>**注意**：文本数据是作为UTF-8编码的文件暴露出来的。要使用其他编码的话，请使用binaryData。

### emptyDir

`emptyDir`数据卷会在Pod指派到一个节点后进行首次创建，只要Pod还在那个节点，那这个数据卷就一直在。人如其名，它一开始是空的。Pod中的容器们可以读写`emptyDir`书卷中的同样的文件，尽管同一个数据卷可能挂载到不同容器的不同路径上。当Pod从一个节点移除了，`emptyDir`中的数据就永久删除了。

>**注意**：容器的崩溃*不会*导致Pod从一个节点移除，所以容器崩溃并不会丢失`emptyDir`中的数据。

一些使用`emptyDir`的场景：

- 当缓存，比如基于磁盘的合并排序
- 某个漫长计算中的检查点，为了在崩溃后进行恢复
- 一个数据容器往里灌数据，另一个web服务容器向外提供这些数据

默认情况下`emptyDir`数据卷存储在节点使用的存储介质上，可能是磁盘、SSD活网络存储，视你的情况而定。但你也可以将`emptyDir.medium`设置为`“Memory”`，让k8s给你挂载一个tmpfs（基于RAM的文件系统）。tmpfs肯定非常快了，但是要知道跟磁盘不同的是，节点重启的话tmpfs会被清掉，而且里面的数据受你的容器的内存大小限制。

#### 栗子

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: k8s.gcr.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir: {}
```

## 使用subPath