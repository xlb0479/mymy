# 概要

本文对`Pod`进行简要介绍，它不光名字简单，在k8s中，可部署的最小对象单元，就是Pod，它是宇宙中的一颗星球、是尘埃、是晶体、是夸克，是你、是我、是众生。

- [理解Pod](#理解Pod)（看完不理解别怪我）
- [与Pod同行](#与Pod同行)
- [Pod模板](#Pod模板)
- [接下来……](#接下来)

## 理解Pod

*Pod*是k8s应用的最小执行单元——可以创建或部署，最小也是最简单的k8s对象。一个Pod也就是[集群]()上的若干个具体进程。

Pod这个对象，它封装了什么呢？它封装了应用的一个容器（有的时候是多个），封装了提供存储功能的资源，封装了唯一的网络身份（IP），以及一些用来维护容器运行的选项。Pod代表了一个部署单元：*k8s一个应用下的一个实例*，可能包含了一个或若干个紧密相关又共享资源的[容器]()。

对于Pod来说，[Docker](https://www.docker.com/)是最常用的容器运行时，但也支持[其他的运行时]()。

在k8s中，Pod主要是这么两种用法：

- **只运行一个容器**。“只生一个好”，这种Pod是最常见的；这种情况下你就可以认为Pod就是一个容器的一层外衣，k8s用的是Pod，而不直接摸容器。
- **运行多个相互协作的容器**。Pod可以包含一组紧密联系、相互协作，且共享资源的容器。这些容器可以组合成一个内聚的服务——一个容器通过共享的数据卷向外部提供文件下载服务，另一个“边儿卡”（sidecar）容器负责更新这些文件。Pod把这些容器以及提供存储能力的资源都封装起来，形成一个单独的可控实体。

每个Pod都是某个应用下的一个实例。比如你想对应用水平扩展（通过多实例来提供更多的处理资源），那你就运行多个Pod，每个Pod是一个实例。在k8s中，这个事儿叫*复制（replication）*。多个Pod副本通常是作为一个整体资源，由其所属的[*控制器*](../../集群架构/控制器.md)来创建和管理的。至于这里面的门道，去看[Pod跟它的控制器](#Pod跟它的控制器)。

### Pod咋管理多个容器

Pod从一开始设计的时候就可以支持让多个相互协作的进程（容器）组合成一个内聚的服务。Pod中的容器手拉手、肩并肩，总是会被调度到同一个物理机或虚拟机上。这戏容器共享资源和依赖，互相聊天扯淡，同生同死。

虽然我这么说了，但是，你要知道，这种多容器的用法，实际上是相当高级的（吹牛逼？）。真的是只有在真的真的容器之间紧耦合的情况下你才应该这么用。比如我们在上文中提到的场景：

![pod](../img/pod.svg)

有些Pod是由[初始化容器]()跟[App容器]()组成的，在App容器运行之前，初始化容器就已经运行完成并结束了。

Pod为它的容器们提供两种可共享的资源：*网络*和*存储*。

#### 网络

每个Pod都有一个唯一的IP。Pod中的每个容器共享这个网络空间，包括IP跟端口。*Pod中*的容器可以用`localhost`跟另一个容器通信。如果容器要跟*Pod外*通信，那它们自己首先要在内部研究好怎么共享这个网络（比如端口）。

#### 存储

Pod可以定义一系列共享的[数据卷]()。Pod里面所有容器可以共享这些数据卷，共享数据。数据卷也可以把数据持久化，比如容器可能需要重启，避免数据丢失。关于这块的东西，你去看看[数据卷]()。

## 与Pod同行

很少有情况说是需要你去直接创建Pod。因为从设计上讲，Pod这个东西它是一种跟微新小程序似的，阅后即焚的东西。Pod创建（直接，或由[*控制器*](../../集群架构/控制器.md)间接的）后就会调度到集群中某个[节点（Node）](../../集群架构/节点（Node）.md)上去跑。Pod会一直跑在那个节点上，直到进程结束，或者Pod被删、因资源紧张被*踢掉（evicted）*，或者节点自己闹妖。

>**注意**：别把容器重启跟Pod重启闹混了。Pod本身并不是一个进程，而是一个用来运行容器的环境。Pod一直存在，直到被删了。

Pod本身并不具备自我恢复的功能。比如Pod被调度到了一个闹妖的节点上，或者调度本身出现什么问题，Pod就直接被删了；如果说因为资源紧张，或者节点要维护，要踢掉一个Pod，那是说踢就踢的，没啥商量的余地。在k8s中，我们使用了一个更高层的概念，叫控制器，用控制器来管理这些阅后即焚的Pod。所以说，虽然可以直接创建Pod，但是一般我们都会使用控制器来管理Pod。

### Pod跟它的控制器

可以用其他玩意来创建、管理Pod。比如要创建Pod副本、平滑上线、自动容错，就可以使用控制器。这种情况下，比如一个节点挂了，控制器就会发现那个节点上的Pod停了，然后给你创建一个新的替代Pod。而调度器会把这个新的Pod调度到一个身心健康的节点上。

以下这几种玩意都可以用来管理一个或多个Pod：

- [Deployment]()
- [StatefulSet]()
- [DaemonSet]()

## Pod模板

控制器可以根据Pod模板来创建、管理Pod，这个模板由你来定义。

Pod模板（PodTemplate）是对Pod的一个声明，也属于一个工作组件，跟[Deployment]()啊、[乔布斯（Jobs）]()啊、[DaemonSet]()啊是一样的。

每个控制器都会使用它工作组件内部的Pod模板来创建Pod。Pod模板本身就是这个工作组件所要达到的目标状态的一部分。

下面是一个简单的Job，用`template`启动了一个容器。容器说了句话，然后暂停了。

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hello
spec:
  template:
    # This is the pod template
    spec:
      containers:
      - name: hello
        image: busybox
        command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
      restartPolicy: OnFailure
    # The pod template ends here
```

修改或者切到一个新的Pod模板，对于已经存在的Pod来说是没有什么直接影响的。Pod并不直接接受来自模板的更新，会有一个满足新模板的Pod被创建出来。

比如，现在一个Deployment控制器已经运行了一堆Pod，满足了当前的Pod模板。如果模板改了，控制器要删了已有的Pod，根据新模板去创建新的Pod。对于Pod模板的更新，每一种控制器都有自己的应对策略。

对于节点来说，[kubelet]()并不直接接触Pod模板及其更新的相关细节问题；这些东西被抽象出去了。这样对整个系统也是一种简化，在不修改节点的情况下就可以对集群的功能进行扩展。

## 接下来……

- 学学[Pod](Pod.md)
- [分布式系统小锦囊：容器的组合模式](https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/)，这里介绍了常见的多容器Pod实现方式。
- 深入Pod：
    - [Pod结束状态](Pod.md#Pod结束状态)
    - [Pod的生命周期](Pod的生命周期.md)