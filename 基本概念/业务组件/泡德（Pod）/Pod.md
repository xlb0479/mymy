# Pod

*Pod*是k8s中可操作的最小计算单元。

- [Pod是啥](#Pod是啥)
- [为啥要闹Pod](#为啥要闹Pod)
- [用处](#用处)
- [其他方案（就是为了突显一下Pod）](#其他方案)
- [Pod持久化（或者说根本不可能持久化）](#Pod持久化（或者说没有持久化）)
- [Pod结束状态](#Pod结束状态)
- [特权模式](#特权模式)
- [API对象](#API对象)

## Pod是啥

一个*Pod*，就像豌豆荚或者鲸鱼荚，就是一组[容器](../../概要/Kubernetes是啥？.md)，它们共享存储/网络，通过一份声明来定义容器如何运行。这里提到的豌豆荚和鲸鱼荚可能不太好理解，说起豌豆荚，你可能会想到应用商店，那我们就换个词：[毛豆](https://baike.baidu.com/item/%E6%AF%9B%E8%B1%86/65885?fr=aladdin)，这玩意你吃过吧，然后你想想毛豆那个样子，一层皮里面包着一个或者多个豆子，这个豆子就相当于容器，外头那层皮就相当于Pod。至于鲸鱼荚，猛的一看，以为我可能打错字了，感觉根本没有这么一个词，的确，你去百度也百度不到这个词，去谷歌也谷歌不到，因为这个词是老外发明的，并且很小众，是专门研究鲸鱼领域的一个词儿，我们就不说荚了，就说Pod，鲸鱼Pod。在对鲸鱼的研究中，一个Pod，就是鲸鱼的一个社交圈，在一个Pod中，母鲸鱼跟幼崽的联系是最紧密的，一个Pod中的鲸鱼会互相保护，齿鲸经常是群居在一个Pod里，一起在大海里游走，一起捕食，一起迁徙，一起保护幼崽们。一个Pod中的东西，都是绑在一起的，协同调度，并且共享同一个上下文。一个Pod就是对一个应用特定的“逻辑主机”在进行建模——包含了一个或多个紧密相连的应用容器——在容器诞生之前，运行在同一个物理机或虚拟机上，就意味着运行在相同的逻辑主机上。

k8s支持的容器运行时不光是Docker，Docker只是最常用的，并且可以用Docker的属于来描述Pod。

我们提到Pod中共享的上下文，其实就是一系列Linux的namespace、cgroup，以及一些其他的隔离概念——Docker本身也是用这些概念来实现容器隔离的。在一个Pod的上下文中，每个应用可能会有更深层次的隔离机制。

Pod中的容器共享同一个IP地址和端口空间，可以用`localhost`来互相通信。它们也可以用其他的标准进程间通信机制，比如SystemV信号量或者POSIX共享内存。不同Pod中的容器IP不同，而且，没有[特殊配置]()的话，也不支持进程间通信。这些容器一般就是用Pod的IP来通信了。

同一个Pod中的应用程序可以共享同一个[数据卷（Volume）]()，数据卷是Pod定义的一部分，可以挂载到每个应用程序的文件系统中。

用[Docker](https://www.docker.com/)的话来说，Pod就是对一组Docker容器来建模，共享namespace和文件系统数据卷。

>**注意**：这里我们多次提到namespace，但是要跟k8s的Namespace区分开来，这里提到的是Linux操作系统层面的隔离机制，并不是k8s提供的应用层面的隔离机制。

跟容器一样，Pod也被认为是一种阅后即焚（而非长久存在）的实体。就像在[Pod生命周期]()中讲的，Pod创建之后，被赋予一个唯一ID（UID），调度到节点上，直到结束（参考重启策略）或被删除。如果一个[节点](../../集群架构/节点（Node）.md)挂了，在一个超时时间之后，这个节点上的Pod就要一点一点被删掉。一个Pod（由UID确定）不会被“重调度”到一个新的节点上；但是可以被一个相同的Pod所替代，如果需要的话连名字也可以不变，但是会有一个新的UID（详见[副本控制器（replication controller）]()）。

如果说某个东西和Pod要同生共死，比如一个数据卷，那就是说Pod（由UID确定）在，它就在，Pod不在，它就没了。如果说Pod被删了，即便建好了一个相同的Pod来替代，和原来Pod相关的那些东西（比如数据卷）也会被销毁并重建。

![pod.svg](../img/pod.svg)

**Pod图示**   
*这是一个包含了多个容器的Pod，一个负责刷新文件，一个负责提供文件服务，在容器之间共享同一个数据卷*

## 为啥要闹Pod

### 方便管理

Pod是一种用多个合作进程组成内聚型服务单元的模式。它在应用程序层面之上提供更高级的抽象，简化了程序的部署和管理。Pod是部署、水平扩展、副本的基本单元。共存（协同调度）、命运共通（同生同死）、副本化协作、资源共享及依赖管理，容器所需的这些功能都自动实现了。

### 资源共享和通信

Pod在其内部实现了数据共享和相互通信。

Pod中的应用程序使用同一个网络空间（相同的IP和端口空间），这样就可以用`localhost`来找到彼此了。正因为如此，同一个Pod中的应用程序必须协商好它们要使用的端口。每个Pod都有一个IP，这些IP存在于一个扁平的、共享网络空间中，可以和网络中的其他物理机或Pod进行功能完备的通信。

Pod中的容器所看到的主机名都是一样的，就是Pod的`name`。这块内容可以通过[网络]()一节学习更多相关知识。

Pod除了能定义容器还可以定义共享的数据卷。数据卷可以提供持久化，并且让Pod中的应用程序可以共享数据。

## 用处

Pod可以用来支持内种垂直集成的应用程序栈（比如LAMP），但主要还是用来支持那些共存、共同管理的辅助程序，比如：

- CMS系统，文件和数据的加载，本地缓存管理等。
- 日志及检查点备份、压缩、切割、快照等。
- 数据变化监视、日志跟踪、日志和监控适配器、事件生产者等。
- 代理、桥接和适配程序。
- 控制器（就是一般的控制器，别跟k8s的控制器搞混了）、管理工具、配置工具、辅助更新程序。

每个Pod中一般不会去运行一个应用的多个实例。

更多更详细的解释，去看[分布式系统小锦囊：容器的组合模式](https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/)。

## 其他方案

*为什么不直接在一个（Docker）容器中运行多个程序呢？*

- 1.透明度。让Pod中的容器对底层基础设施可见，这样就可以给容器提供一些来自大自然的力量，比如进程管理和资源监控。这给用户提供了很大的便利。
- 2.解耦软件依赖。每个容器可以有自己的版本，各自重建、重新部署。k8s在未来甚至可能实现容器级的实时更新。
- 3.用法简单。用户不用自己操心进程管理，操心信号（signal）和进程退出码（exit-code）的传播机制等等。
- 4.高效。基础设施层面参与了大量工作，容器也就变得更加轻量级。

*为什么不支持基于亲和性的容器协同调度？*

这种技术可以实现容器的共存，但是Pod其他大部分的优点就没了，比如资源共享、进程间通信、命运共通和管理化简。

## Pod持久化（或者说没有持久化）

