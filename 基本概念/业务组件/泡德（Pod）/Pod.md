# Pod

*Pod*是k8s中可操作的最小计算单元。

- [Pod是啥](#Pod是啥)
- [咋来的](#咋来的)
- [用处](#用处)
- [其他方案](#其他方案)
- [Pod持久化（或者说根本不可能持久化）](#Pod持久化（或者说根本不可能持久化）)
- [Pod结束状态](#Pod结束状态)
- [特权模式](#特权模式)
- [API对象](#API对象)

## Pod是啥

一个*Pod*，就像豌豆荚或者鲸鱼荚，就是一组[容器](../../概要/Kubernetes是啥？.md)，它们共享存储/网络，通过一份声明来定义容器如何运行。这里提到的豌豆荚和鲸鱼荚可能不太好理解，说起豌豆荚，你可能会想到应用商店，那我们就换个词：[毛豆](https://baike.baidu.com/item/%E6%AF%9B%E8%B1%86/65885?fr=aladdin)，这玩意你吃过吧，然后你想想毛豆那个样子，一层皮里面包着一个或者多个豆子，这个豆子就相当于容器，外头那层皮就相当于Pod。至于鲸鱼荚，猛的一看，以为我可能打错字了，感觉根本没有这么一个词，的确，你去百度也百度不到这个词，去谷歌也谷歌不到，因为这个词是老外发明的，并且很小众，是专门研究鲸鱼领域的一个词儿，我们就不说荚了，就说Pod，鲸鱼Pod。在对鲸鱼的研究中，一个Pod，就是鲸鱼的一个社交圈，在一个Pod中，母鲸鱼跟幼崽的联系是最紧密的，一个Pod中的鲸鱼会互相保护，齿鲸经常是群居在一个Pod里，一起在大海里游走，一起捕食，一起迁徙，一起保护幼崽们。一个Pod中的东西，都是绑在一起的，一同调度，并且共享同一个上下文。一个Pod就是对一个应用特定的“逻辑主机”在进行建模——包含了一个或多个紧密相连的应用容器——在容器诞生之前，运行在同一个物理机或虚拟机上，就意味着运行在相同的逻辑主机上。

k8s支持的容器运行时不光是Docker，Docker只是最常用的，并且可以用Docker的属于来描述Pod。

我们提到Pod中共享的上下文，其实就是一系列Linux的namespace、cgroup，以及一些其他的隔离概念——Docker本身也是用这些概念来实现容器隔离的。在一个Pod的上下文中，每个应用可能会有更深层次的隔离机制。

Pod中的容器共享同一个IP地址和端口范围，可以用`localhost`来互相通信。它们也可以用其他的标准进程间通信机制，比如SystemV信号量或者POSIX共享内存。不同Pod中的容器IP不同，而且，没有[特殊配置]()的话，也不支持进程间通信。这些容器一般就是用Pod的IP来通信了。

同一个Pod中的应用程序可以共享同一个[数据卷（Volume）]()，数据卷是Pod定义的一部分，可以挂载到每个应用程序的文件系统中。

用[Docker](https://www.docker.com/)的话来说，Pod就是对一组Docker容器来建模，共享namespace和文件系统数据卷。

>**注意**：这里我们多次提到namespace，但是要跟k8s的Namespace区分开来，这里提到的是Linux操作系统层面的隔离机制，并不是k8s提供的应用层面的隔离机制。

跟容器一样，Pod也被认为是一种阅后即焚（而非长久存在）的实体。就像在[Pod生命周期]()中讲的，Pod创建之后，被赋予一个唯一ID（UID），调度到节点上，直到结束（参考重启策略）或被删除。如果一个[节点](../../集群架构/节点（Node）.md)挂了，在一个超时时间之后，这个节点上的Pod就要一点一点被删掉。一个Pod（由UID确定）不会被“重调度”到一个新的节点上；但是可以被一个相同的Pod所替代，如果需要的话连名字也可以不变，但是会有一个新的UID（详见[副本控制器（replication controller）]()）。

如果说某个东西和Pod要同生共死，比如一个数据卷，那就是说Pod（由UID确定）在，它就在，Pod不在，它就没了。如果说Pod被删了，即便建好了一个相同的Pod来替代，和原来Pod相关的那些东西（比如数据卷）也会被销毁并重建。

![pod.svg](../img/pod.svg)

**Pod图示**   
*这是一个包含了多个容器的Pod，一个负责刷新文件，一个负责提供文件服务，在容器之间共享同一个数据卷*

## 咋来的

