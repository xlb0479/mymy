# 分裂（Disruptions）

对于那些意图打造高可用应用程序的年轻的樵夫，需要知道Pod会发生哪些分裂情况。

对于集群管理员也一样，他们可能要做一些集群自动化操作，比如升级或者自动扩容。

- [自主分裂和非自主分裂](#自主分裂和非自主分裂)
- [处理分裂](#处理分裂)
- [PDB的作用](#PDB的作用)
- [PDB示例](#PDB示例)
- [区分集群拥有者和应用程序的拥有者](#区分集群拥有者和应用程序的拥有者)
- [如何进行分裂操作](#如何进行分裂操作)
- [接下来……](#接下来)

## 自主分裂和非自主分裂

Pod的离开，都是有原因的，比如人为（人类或控制器）的原因，或者说硬件或操作系统出问题了。

我们把这种不可避免的情况称为应用的*非自主分裂（involuntary disruption）*。比如：

- 节点的底层硬件出错
- 管理员误删虚拟机（实例）
- 云服务商或者hypervisor出错，把虚拟机闹没了
- 内核崩了
- 由于网络问题，节点失联
- 由于[资源不足]()要踢掉Pod

除了最后一条，其他几条大部分用户应该都清楚是咋回事，因为这些情况不仅发生在k8s上。

除了以上的情况，其他情况我们称之为*自主分裂（voluntary disruption）*。其中包括了程序拥有者跟集群管理员都可能触发的动作。程序拥有者可能的动作包括：

- 删除了负责管理Pod的Deployment或其他控制器
- 修改Pod的模板，导致重启
- 直接把Pod删了（可能时误操作）

集群管理员的动作包括：

- 某个节点要维护或升级，需要把节点[抽成干尸（Drain）]()。
- 同样是把节点抽成干尸，但是是因为集群需要缩容（详见[集群的自动扩容]()）
- 把Pod从一个节点上删掉，好让另一个Pod能上的来。

这些动作可能是集群管理员直接操作，也可能是自动化程序，或者是集群服务商操作的。

问问集群管理员、云服务商、或者看看文档，看看集群都应用了哪些自主分裂行为。如果啥也没用，那你可以不用创建Pod分裂巴基特（Pod Disruption Budget）。

> **小心**：Pod分裂巴基特并不能限制所有自主分裂。比如删除Deployment或Pod就不受巴基特控制。

## 处理分裂

有这么几个方法可以缓和自主分裂：

- 确定Pod[申请的资源]()是它真实需要的。
- 如果想让应用支持高可用，那就要创建副本。（可以学学如果创建[无状态]()和[有状态]()的应用。）
- 要获得更高的可用性，在机甲之间（用[反亲和性]()）或区域之间（如果用了[多区域集群]()）分散应用的副本。

自主分裂的频率多种多样。在一个基本的k8s集群上，压根儿就没有自主分裂。但是人类的活动会在上面运行一些服务，从而导致了自主分裂。比如滚动发布节点软件更新时，就会导致自主分裂。还有一些集群（节点）的自动扩容可能也会导致自主分裂，因为这个时候可能要做一些碎片整理或者节点压缩。集群管理员或者服务商应当有相关文档，标明可能会发生的自主分裂行为。

k8s有一些工具能帮你在频繁的自主分裂期间依然保持应用的高可用。我们把这些工具称为*分裂巴基特（Disruption Budget）*。

## PDB的作用

应用的拥有者可以为每个应用创建一个`PodDisruptionBudget`对象（PDB）。PDB是用来限制自主分裂时可以同时down掉多少个应用副本。比如一些基于quorum的应用，它们就会要求某些副本数不能低于指定的quorum数。而一个Web前端应用可能要求副本数不能低于某个百分比。

集群管理者或者服务商，应该使用支持PDB的[剔除（Eviction）API]()而不是直接删除Pod或Deployment。比如`kubectl drain`命令，以及GCE环境下的集群升级脚本（`cluster/gce/upgrade.sh`）。

当集群管理员想要把某个节点抽成干尸时，那就要用`kubectl drain`命令。这个命令会将节点上的所有Pod都剔除掉。剔除请求可能会被短暂的拒绝，但是这个命令会不断的重试，直到所有的Pod都停掉了，或者说到了某个预设的超时时间。

PDB声明了一个应用至少要有多少个副本。比如一个Deployment的`.spec.replicas: 5`就是说任何时候都要有5个副本。如果它的PDB允许可以为4个副本，那专用的剔除API就会允许在某一时刻自主分裂至多一个Pod。

组成应用的Pod由标签选择器而定，应用的控制器（Deployment、StatefulSet等）也是用这个东西来选定Pod的。

“意图”达到的Pod数量是根据控制器的`.spec.replicas`来计算的。在Pod中可以用`.metadata.ownerReferences`来反向找到它的控制器。

PDB并不能阻止[自主分裂](#自主分裂和非自主分裂)的发生，但它们都是要计入PDB的。

当Pod因为应用的滚动升级而删除或不可用时，会计入PDB，但是控制器（比如Deployment、StatefulSet）在滚动升级时不会受到PDB的限制——应用更新时的错误处理时配置在控制器的spec中的。（详见[更新Deployment]()）

如果用剔除API来踢掉Pod，此时Pod是优雅关闭的（见[PodSpec]()中的`terminationGracePeriodSeconds`。）

## PDB示例

假设一个3节点的集群，从`node-1`到`node-3`。集群上运行着若干应用。启用一个有3个副本，`pod-a`，`pod-b`，`pod-c`。另外还有一个路人Pod，带PDB，称为`pod-x`。起初的样子是这样的，十分青涩：

node-1|node-2|node-3
-|-|-
pod-a *available*|pod-b *available*|pod-c *available*
pod-x *available*

3个Pod同属一个Deployment，有一个共同的PDB，要求任一时刻至少要有两个Pod活着。

比如此时集群管理员要重启节点，升级内核修复一个Bug。首先，管理员要用`kubectl drain`命令抽干`node-1`。命令会将`pod-a`和`pod-x`踢掉。这个命令会立即成功。这俩Pod同时转入`terminating`状态。此时集群状态如下：

node-1 *draining*|node-2|node-3
-|-|-
pod-a *terminating*|pod-b *available*|pod-c *available*
pod-x *terminating*

Deployment会发现其中一个Pod正在停止，所以它要创建一个新的`pod-d`。因为`node-1`被抽走了，新Pod会落到其他节点上。同时也会有一个`pod-y`诞生，用来替代`pod-x`。

（注意：对于StatefulSet来说，`pod-a`，具体可能称为`pod-0`，在被替代前，必须完全停掉，然后再建出来一个`pod-0`，但是UID不一样了。StatefulSet的其他部分跟本例描述的情况是一样的。）

此时的集群如下：

node-1 *draining*|node-2|node-3
-|-|-
pod-a *terminating*|pod-b *available*|pod-c *available*
pod-x *terminating*|pod-d *starting*|pod-y

再过一会儿，Pod完全停掉，集群变成：

node-1 *drained*|node-2|node-3
-|-|-
 |pod-b *available*|pod-c *available*
 |pod-d *starting*|pod-y

此时，狂躁的集群管理员想要抽干`node-2`和`node-3`，执行同样的命令，但是会被阻塞，因为Deployment下目前只剩下2个Pod了，到了PDB设定的下限了。再过一会儿，`pod-d`状态变为可用。

此时集群如下：

node-1 *drained*|node-2|node-3
-|-|-
 |pod-b *available*|pod-c *available*
 |pod-d *available*|pod-y

这时集群管理员尝试抽掉`node-2`。命令会尝试以某种顺序来踢掉这两个Pod，比如先`pod-b`再`pod-d`。它会成功踢掉`pod-b`。但是当要踢掉`pod-d`时，操作会被拒绝，因为那样的话Deployment就剩下一个可用的Pod了。

Deployment会创建一个用来替代`pod-b`的`pod-e`。因为此时集群中已经没有足够的资源来调度`pod-e`了，命令再次被阻塞了。然后集群状态变成下面这个吊样子：

node-1 *drained*|node-2|node-3|*节点未分配*
-|-|-|-
 |pod-b *available*|pod-c *available*|pod-e *pending*
 |pod-d *available*|pod-y

此时，集群管理员要想留着自己的狗命，完成升级，就得给集群再加一个节点进来。

通过上面的学习，你会发现k8s基于不同的情况来调整分裂的频率：

- 应用需要多少副本
- 优雅关闭一个实例需要多久
- 新的实例需要多久才能启动
- 控制器的类型
- 集群资源容量

## 区分集群拥有者和应用程序的拥有者

很多时候应当把集群管理员跟应用程序的拥有者这两种角色分开，每个角色只关心自己该关心的事儿。这种职责划分在下面的场景中是有必要的：

- 有多个应用团队共享同一个k8s集群，自然要有不同的角色划分
- 使用第三方工具或服务实现自动化集群管理

PDB为角色之间提供接口，支持这种角色划分。

如果说你的组织不存在这种职责划分，那你可能不需要使用PDB。

## 如何进行分裂操作

如果你是集群管理员，你要在集群的所有节点上执行一个分裂操作，比如节点或系统的软件需要升级，这里给出一些选择：

- 允许存在停机窗口。
- 有另外的集群提供灾备。
    - 用户无感知，但可能要在节点复制以及安排切换工作上下一些功夫。
- 编写能够容忍分裂的应用并且使用PDB。
    - 用户无感知。
    - 最小化资源浪费。
    - 能够支持更多的集群自动化管理工作。
    - 虽然说编写容忍分裂的应用可能需要点技巧，但是写完之后很可能同时可以支持自动扩容，并且还能容忍那种非自主的分裂。

## 接下来……

- 实战：[配置PDB]()
- 学学如何把节点[抽成干尸]()