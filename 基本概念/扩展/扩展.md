# 扩展

k8s是高度可配置、可扩展的。因此一般都不需要对k8s的代码做fork或者提交补丁。

本文将介绍可以自定义k8s集群的各种方法。主要提供给那些[集群操作者](https://v1-18.docs.kubernetes.io/docs/reference/glossary/?all=true#term-cluster-operator)，想让k8s集群能够适配他们当前的环境。做k8s[平台开发](https://v1-18.docs.kubernetes.io/docs/reference/glossary/?all=true#term-platform-developer)或k8s项目的[贡献者](https://v1-18.docs.kubernetes.io/docs/reference/glossary/?all=true#term-contributor)们同样可以从本文得到帮助，了解存在哪些扩展点和扩展模式，以及相关的利弊权衡与限制。

## 概要

进行自定义的方法可以大体上分为*配置*，只需要修改参数、本地配置文件或者API资源；和*扩展*，需要运行额外的程序或服务。本文主要介绍的是扩展。

## 配置

*配置文件*和*参数*在每个二进制文件对应的在线参考文档中都有介绍：

- [kubelet](https://v1-18.docs.kubernetes.io/docs/reference/command-line-tools-reference/kubelet/)
- [kube-apiserver](https://v1-18.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/)
- [kube-controller-manager](https://v1-18.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/)
- [kube-scheduler](https://v1-18.docs.kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/)。

如果k8s是托管的或者安装受控，参数和配置文件可能没法改。如果能改的话，一般也都是只能让集群管理员去改。而且，这些内容在之后的版本中可能会发生变化，而且修改的话可能还要重启相关的进程。出于这些原因吧，这么做只能属于下下策。

*内置策略API*，比如[ResourceQuota](../策略/资源配额.md)、[PodSecurityPolicy](../策略/Pod安全策略.md)、[NetworkPolicy](../Service，负载均衡，网络/网络策略.md)，以及角色访问控制（[RBAC](https://v1-18.docs.kubernetes.io/docs/reference/access-authn-authz/rbac/)），都是内置的k8s API。在托管的k8s或者安装受控的情况下一般都会使用API。它们都是声明式的，规范都跟其他的k8s资源比如Pod差不多，所以，新集群配置可以重复操作，而且可以像应用一样进行管理。再而且吧，当它们稳定之后，可以像其他k8s的API一样享受到[既定的支持策略](https://v1-18.docs.kubernetes.io/docs/reference/using-api/deprecation-policy/)。出于这些原因吧，同样的情况下要比*配置文件*和*参数*更加方便。

## 扩展

扩展（Extension）是软件组件，扩展的同时也深度集成到了k8s中。它们通过自身的适配，可以支持新的类型以及新的硬件种类。

大部分集群管理员用的都是托管或者发行版的k8s实例。因此大部分k8s用户不需要安装扩展，而且也不需要创造什么新的扩展。

## 扩展模式

k8s从设计上支持编写客户端程序然后自动运转。任何读写k8a API的程序都可以提供有意义的自动化机制。*自动化*可以在集群上运行，也可以脱离集群。按照本文的指引，你就可以写出高可用、健壮的自动化机制。自动化一般都可以运行在各种k8s集群上，包括托管集群和受控安装。

写这种跟k8s配合良好的客户端程序是有特定模式的，叫做*控制器（Controller）* 模式。控制器一般要读取一个对象的`.spec`，然后搞点儿事情，然后再更新对象的`.status`。

一个控制器就是一个k8s的客户端。如果是k8s作为客户端，调用一个外部的远程服务，那它就叫*Webhook*。对应的远程服务叫做*Webhook Backend*。跟控制器类似，Webhook也会引入失败点（point of failure）。

在webhook模式中，k8s要向远程服务发起一个网络请求。在*二进制插件（Binary Plugin）* 模式中，k8s要执行一个二进制文件（程序）。二进制插件会用于kubelet（比如[Flex数据卷插件](../存储/数据卷.md#FlexVolume)和[网络插件](计算，存储与网络拓展/网络插件.md)）以及kubectl。

下图展示了扩展点如何跟k8s的控制面进行交互。

![K8s extending concept guide fig 1.png](img/K8s extending concept guide fig 1.png)