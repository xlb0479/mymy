# 网络插件

**功能状态**：`Kubernetes v1.18 [alpha]`

>**小心**：Alpha版本的东西变得很快。

k8s中的网络插件有这么几种：

- CNI插件：遵守appc或CNI规范，为互操作性而设计。
- k8s插件：使用`bridge`和`host-local`CNI插件实现了基本的`cbr0`。

上面这两行借鉴了官方的翻译。

## 安装

kubelet只有一个默认的网络插件，以及为整个集群提供一个默认的常用网络。它在启动的时候会探测插件，记住它探测到的结果，然后Pod生命周期中合适的时间点上运行插件（只有对Docker才这样，因为rkt管理它自己的CNI插件）。使用插件的时候，需要记住两个Kubelet的命令行参数：

- `cni-bin-dir`：Kubelet在启动的时候从这个目录中探测插件
- `network-plugin`：在`cni-bin-dir`中要使用的网络插件。它必须匹配从插件目录中探测到的插件名。对于CNI插件，那就是“cni”。

## 网络插件要求

除了要提供[`NetworkPlugin`接口](https://github.com/kubernetes/kubernetes/blob/v1.18.8/pkg/kubelet/dockershim/network/plugins.go)来配置和清理Pod网络，插件可能还需要为kube-proxy实现特定的支持。iptables代理自然要依赖iptables，插件要确保容器的网络对iptables是可用的。比如把，如果插件把容器连到了Linux bridge上，插件必须要将sysctl的`net/bridge/bridge-nf-call-iptables`设置成`1`，确保iptables代理工作正常。如果插件不用Linux bridge（而是用了像Open vSwitch或者其他机制），那它就要确保容器网络为代理做好了合适的路由。

默认情况下，如果没有指定kubelet网络插件，那就使用`noop`插件，它会设置`net/bridge/bridge-nf-call-iptables=1`，确保这种简单的配置（类似基于bridge的Docker）能够跟iptables代理一起正常的工作。

### CNI

在Kubelet的命令行选项中设置`--network-plugin=cni`就可以选择CNI插件了。Kubelet会从`--cni-conf-dir`（默认是`/etc/cni/net.d`）中读取CNI配置文件，然后建立每个Pod的网络。CNI配置文件必须要满足[CNI规范]()，配置中引用到的所有CNI插件必须都要存在于`--cni-bin-dir`（默认是`/opt/cni/bin`）中。

如果目录中有多个CNI配置文件，kubelet会按照文件名字典序排序然后使用第一个配置文件。

除了配置文件中指定的CNI插件，k8s还需要标准的CNI[`lo`](https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go)插件，最低版本是0.2.0。