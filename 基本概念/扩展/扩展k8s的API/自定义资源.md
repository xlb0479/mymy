# 自定义资源

*自定义资源（Custom Resource）* 是k8s API的扩展。本文要讨论的是什么时候要加一个自定义资源，什么时候要用独立的服务。这里描述了两种添加自定义资源的方法以及如何在它们之间做出选择。

## 自定义资源

一个*资源*就是[k8s API](https://v1-18.docs.kubernetes.io/docs/reference/using-api/api-overview/)中的一个endpoint，保存了一组某种类型的[API对象](../../概要/Kubernetes对象/理解Kubernetes对象%20.md)；比如内置的*pod*资源包含了Pod对象的集合。

一个*自定义资源*就是k8s API的一个扩展，不需要在默认的k8s安装中体现出来。它代表着对k8s安装的一种定制。当我们安装了一个自定义资源后，用户可以通过[kubectl](https://v1-18.docs.kubernetes.io/docs/reference/kubectl/overview/)来创建、访问它的对象，就跟使用内置的*Pod*资源一样。

## 自定义控制器

自定义资源自身可以让你保存、读取结构化的数据。当你结合了自定义资源和*自定义控制器（custom controller）* 后，自定义资源就提供了一个真正意义的*声明式API*。

一个[声明式API（declarative API）](../../概要/Kubernetes%20API.md)允许你*声明*或定义该资源的目标状态（desired state），并尝试将k8s对象的当前状态保持在目标状态上。控制器会将结构化的数据解释成用户设定的目标状态记录，然后持续性的维护这个状态。

你可以在集群上部署、更新一个自定义控制器，它独立于集群的生命周期。自定义控制器可以跟任意类型的资源配合工作，但它们跟自定义资源配合的时候才是最有效的时候。[Operator模式](https://coreos.com/blog/introducing-operators.html)结合了自定义资源和自定义控制器。可以用自定义控制器将应用特定的领域知识编码到k8s API的扩展中。

## 我是否需要添加自定义资源？

当创建一个新的API的时候，考虑是否要[将你的API聚合到k8s集群API中](通过聚合层扩展k8s的API.md)或者让你的API另起炉灶。

**考虑API聚合，当：**|**让API另起炉灶，当：**
-|-
你的API是[声明式的](#声明式API)。|你的API并不是[声明式的](#声明式API)。
你想让你的新类型可以用`kubectl`进行读写|不需要`kubectl`的支持
你想要在k8s UI中看到你的新类型，比如dashboard，以及其他的内置类型|不需要k8s UI的支持。
你正在开发一个新的API|你已经有一个程序来提供API了，并且工作的很好。
你想接受k8s对REST资源路径做的格式限制，比如API分组和命名空间。（见[API概要](../../概要/Kubernetes%20API.md)。）|在你已经定义好的REST API中，有特殊的REST路径需要兼容。
你的资源本身就是面向集群或者命名空间的|并不适合集群或命名空间的概念；你需要控制资源路径的特性。
你想重用[k8s API支持特性](#一般特性)。|不需要这些特性。

### 声明式API

在声明式API中，一般来说：

- 你的API包含较少且较小的对象（资源）。
- 对象定义的是应用或基础设施的配置。
- 对象极少需要更新。
- 人们经常需要读写对象。
- 对象的主要操作就是CRUD（增删改查）。
- 不需要跨对象的事务：API代表的是目标状态，而非准确状态。

命令式API可不是声明式的。你的API不该是：

- 客户端说“干吧”，然后等工作完成后得到同步的响应。
- 客户端说“干吧”，然后返回了一个操作ID，然后需要检查一个Operation对象来判断请求是否已经完成。
- 使用远程过程调用（RPC）。
- 直接存储了大量的数据；比如每个对象大于几kB，或者有大于1000个对象。
- 需要大带宽（每秒至少维持着10个请求）。
- 保存终端用户数据（比如镜像、PII等）或者应用需要处理的其他大规模数据。
- 对象的一般操作不是CRUD。
- API无法轻松地建模成对象。
- 你把即将进行的操作抽象成了操作ID或者一个操作对象。

## 我是要用configMap还是自定义资源？

如果是以下场景，那就用ConfigMap：

- 已经有一个文档写的很好的配置文件格式，比如`mysql.cnf`或`pom.xml`。
- 需要把整个配置文件放到configMap的一个key中。
- 配置文件的主要作用是集群中的Pod用它来对自身进行配置。
- 使用该文件的方式主要是通过Pod中的文件或者环境变量，而非k8s的API。
- 当文件更新后，想通过Deployment等进行实现滚动更新。

>**注意**：对于敏感数据要用[Secret](../../配置/Secret.md)，比ConfigMap更小更安全。

如果基本上属于以下场景，那就用自定义资源（CRD或聚合API）：

- 你想用k8s客户端库或者CLI来创建和更新这个新的资源。
- 你需要`kubectl`提供顶级支持；比如`kubectl get my-object object-name`。
- 你想为这个新的对象构建自动化（automation），监视它的更新，然后对其他对象进行CRUD，或者反过来也行。
- 你想编写自动化（automation）来处理对象的更新。
- 你想用k8s的API规范，比如`.spec`、`.status`和`.metadata`。
- 你希望这个对象是某一类受控资源集合的抽象，或者其他资源的某种归纳。

## 添加自定义资源

k8s提供了两种添加自定义资源的方法：

- 很简单的CRD，不需要编程就能创建。
- [API聚合](通过聚合层扩展k8s的API.md)需要编程，但是能对API行为进行更多的空值，比如数据如何存储、API版本间的转换。

k8s提供的这两种方法满足了不同的用户，既简单又灵活。

聚合API就是在主apiserver后面再加附属的apiserver，主apiserver扮演代理角色。这种组合就叫[API聚合（API Aggregation，AA）](通过聚合层扩展k8s的API.md)。对用户来说，看上去就是k8s的API被扩展了。

CRD不需要添加apiserver也能让用户创建新的资源类型。使用CRD不需要去理解API聚合。

不管怎么安装，新的资源都叫自定义资源（Custom Resource），区别于内置的k8s的资源（比如pod）。

## CustomResourceDefinition

[CustomResourceDefinition](https://v1-18.docs.kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/)这种API资源允许你定义自定义资源。定义一个CRD对象就创建了一个新的自定义资源，包括一个名字和一个schema。k8s的API负责存储你的自定义资源。CRD对象的名字必须是有效的[DNS子域名](../../概要/Kubernetes对象/对象的名字和ID.md#DNS子域名)。

这样就不需要你提供apiserver来处理自定义资源了，但是这种实现方式就意味着不如[apiserver聚合](#apiserver聚合)更加灵活。

参考[自定义控制器示例](https://github.com/kubernetes/sample-controller)来注册新的自定义资源，看看你的新资源的实例，以及控制器是如何处理各种事件的。

## apiserver聚合

### 一般特性